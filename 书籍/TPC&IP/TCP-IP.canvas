{
	"nodes":[
		{"type":"text","text":"-   [TLS 握手过程](https://xiaolincoding.com/network/2_http/https_rsa.html#tls-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B)\n       ![](lecture-note/Pasted%20image%2020230424183632.png)\n       每一个「框」都是一个记录（_record_）\n       **通常经过「四个消息」完成 TLS 握手,2个 RTT 的时延**\n-   [RSA 握手过程](https://xiaolincoding.com/network/2_http/https_rsa.html#rsa-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B):  \n       客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端。根据非对称加密算法，服务端解密后，双方就得到了相同的密钥，再用它加密应用消息\n       ![](lecture-note/Pasted%20image%2020230424184502.png)\n       \n    -   [TLS 第一次握手](https://xiaolincoding.com/network/2_http/https_rsa.html#tls-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B)\n          ![](lecture-note/Pasted%20image%2020230424184751.png)\n          \n    -   [TLS 第二次握手](https://xiaolincoding.com/network/2_http/https_rsa.html#tls-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B)\n          ![](lecture-note/Pasted%20image%2020230424184906.png)\n          密码套件:形式「**密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法**」\n              “Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256”\n                   由于 WITH 单词只有一个 RSA，则密钥交换算法和签名算法都是使用 RSA；\n                   握手后通信使用 AES 对称算法，密钥长度 128 位，分组模式是 GCM；\n                   摘要算法 SHA256 用于消息认证和产生随机数\n    -    [客户端验证证书](https://xiaolincoding.com/network/2_http/https_rsa.html#%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%AA%8C%E8%AF%81%E8%AF%81%E4%B9%A6)\n        ![](lecture-note/Pasted%20image%2020230424185607.png)\n    -   [TLS 第三次握手](https://xiaolincoding.com/network/2_http/https_rsa.html#tls-%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B)\n          客户端生成 (_pre-master_)**，用服务器的 RSA 公钥加密该随机数，通过「**Client Key Exchange**」消息传给服务端\n          服务端收到后， RSA 私钥解密,生成**会话密钥**，客户端发「**Change Cipher Spec**」「**Encrypted Handshake Message（Finishd）**」\n    -   [TLS 第四次握手](https://xiaolincoding.com/network/2_http/https_rsa.html#tls-%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B)\n          服务器发「**Change Cipher Spec**」和「**Encrypted Handshake Message**」\n-   [RSA 算法的缺陷](https://xiaolincoding.com/network/2_http/https_rsa.html#rsa-%E7%AE%97%E6%B3%95%E7%9A%84%E7%BC%BA%E9%99%B7)\n           **不支持前向保密**\n            ECDHE 密钥协商算法","id":"9777c3f9e465367a","x":2460,"y":240,"width":620,"height":700},
		{"type":"text","text":"HTTPS ECDHE 握手解析\n\n---\n\n-   [离散对数](https://xiaolincoding.com/network/2_http/https_ecdhe.html#%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0)\n       ![](lecture-note/Pasted%20image%2020230424191145.png)\n       ![](lecture-note/Pasted%20image%2020230425130728.png)\n       a 和 p 是公共参数，b 是真数，i 是对数。知道i，可以算出b。但反过来，知道b却很难推算出i。\n       **特别是 p 是一个很大的质数，即使知道a 和 b ，几乎无法算出i的，这就是 DH 算法的数学基础**\n-   [DH 算法](https://xiaolincoding.com/network/2_http/https_ecdhe.html#dh-%E7%AE%97%E6%B3%95)\n     小红和小明各自生成一个随机整数作为**私钥**， a ， b  ![](lecture-note/Pasted%20image%2020230425131249.png)\n     K 就是**对称加密密钥**，作为会话密钥\n     \n-   [DHE 算法](https://xiaolincoding.com/network/2_http/https_ecdhe.html#dhe-%E7%AE%97%E6%B3%95)\n       私钥生成的方式，DH 算法分为两种实现:\n             static DH 算法里有一方的私钥是静态,**不具备前向安全性**\n             DHE 算法,每次密钥交换通信时，都是随机生成的、临时的\n-   [ECDHE 算法](https://xiaolincoding.com/network/2_http/https_ecdhe.html#ecdhe-%E7%AE%97%E6%B3%95)\n          DHE 算法由于计算性能不佳，要做大量的乘法，—— **ECDHE 算法**:\n               在 DHE 算法的基础上利用了 ECC 椭圆曲线特性:\n                  确定椭圆曲线，曲线基点 G，公开；生成随机数私钥d，公钥Q（Q = dG）\n                  小红（x1，y1） = d1Q2，小明（x2，y2） = d2Q1\n                  d1Q2 = d1d2G = d2d1G = d2Q1 ，双方的 x 坐标一样，所以它是共享密钥，也就是会话密钥\n-   [ECDHE 握手过程](https://xiaolincoding.com/network/2_http/https_ecdhe.html#ecdhe-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B)\n          ![](lecture-note/Pasted%20image%2020230425134550.png)\n          **ECDHE 相比 RSA 握手过程省去了一个消息往返的时间**，这个有点「抢跑」的意思，它被称为是「_TLS False Start_」\n    -   [TLS 第一次握手](https://xiaolincoding.com/network/2_http/https_ecdhe.html#tls-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B)\n           ![](lecture-note/Pasted%20image%2020230425134652.png)\n           \n    -   [TLS 第二次握手](https://xiaolincoding.com/network/2_http/https_ecdhe.html#tls-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B)\n           ![](lecture-note/Pasted%20image%2020230425134711.png)\n           「**Certificate**」「**Server Key Exchange**」\n           ![](lecture-note/Pasted%20image%2020230425135045.png)\n           -   服务器：定曲线**，基点 G ，生私钥，保留到本地；算公钥**，用 RSA 给公钥签名。\n           - 「**Server Hello Done**」\n    -   [TLS 第三次握手](https://xiaolincoding.com/network/2_http/https_ecdhe.html#tls-%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B)\n           算好会话密钥（**「客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密钥）**）后，客户端发「**Change Cipher Spec**」「**Encrypted Handshake Message**」\n    -   [TLS 第四次握手](https://xiaolincoding.com/network/2_http/https_ecdhe.html#tls-%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B)\n           服务端「**Change Cipher Spec**」和「**Encrypted Handshake Message**」\n-   [总结](https://xiaolincoding.com/network/2_http/https_ecdhe.html#%E6%80%BB%E7%BB%93)\n          RSA 和 ECDHE 握手过程的区别：\n              RSA 「不支持」前向保密，ECDHE 「支持」；\n              RSA ：TLS 四次握手后应用数据传输， ECDHE 算法，客户端可以提前发出加密的 HTTP 数据\n              ECDHE：在TLS 第 2 次握手出现服务器端发出的「Server Key Exchange」消息，而 RSA 握手过程没有该消息；","id":"d12727fba136541e","x":3240,"y":240,"width":680,"height":700},
		{"type":"text","text":"既然有 HTTP 协议，为什么还要有 RPC？\n\n---\n\n-   [从 TCP 聊起](https://xiaolincoding.com/network/2_http/http_rpc.html#%E4%BB%8E-tcp-%E8%81%8A%E8%B5%B7)\n     -  `fd = socket(AF_INET,SOCK_STREAM,0);`\n         -   `SOCK_STREAM`，就是 **TCP 协议** \n-   [使用纯裸 TCP 会有什么问题](https://xiaolincoding.com/network/2_http/http_rpc.html#%E4%BD%BF%E7%94%A8%E7%BA%AF%E8%A3%B8-tcp-%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98)\n     -  **面向连接**、**可靠**、基于**字节流**\n     -   **粘包问题**:  加入**消息头**/**协议**\n-   [HTTP 和 RPC](https://xiaolincoding.com/network/2_http/http_rpc.html#http-%E5%92%8C-rpc)\n     -   **RPC**（**R**emote **P**rocedure **C**all）远程过程调用\n         -  RPC 不一定非得使用 TCP，改用 UDP 或者 HTTP也可以做到类似的功能\n    -  HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 。但现在慢慢融合。很多软件同时支持多端\n-   [HTTP 和 RPC 有什么区别](https://xiaolincoding.com/network/2_http/http_rpc.html#http-%E5%92%8C-rpc-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB)\n    -   [服务发现](https://xiaolincoding.com/network/2_http/http_rpc.html#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0)\n         -  **HTTP** 中，域名通过 **DNS 服务**去解析得到 IP ，默认 80 。\n         -  **RPC** : **中间服务**去保存服务名和IP信息，比如 (**Consul 或者 Etcd、Redis**)、也有基于 DNS 做服务发现的组件，比如**CoreDNS**。 \n    -   [底层连接形式](https://xiaolincoding.com/network/2_http/http_rpc.html#%E5%BA%95%E5%B1%82%E8%BF%9E%E6%8E%A5%E5%BD%A2%E5%BC%8F)\n        -  建个**连接池**\n    -   [传输的内容](https://xiaolincoding.com/network/2_http/http_rpc.html#%E4%BC%A0%E8%BE%93%E7%9A%84%E5%86%85%E5%AE%B9)\n        -  **Header** ：**消息体长度** \n        -  Body: **序列化**--01字符串 **Json，Protobuf**\n-   [总结](https://xiaolincoding.com/network/2_http/http_rpc.html#%E6%80%BB%E7%BB%93)","id":"27f4cfaa85447836","x":1040,"y":1913,"width":667,"height":727},
		{"type":"text","text":"HTTP/2 牛逼在哪？\n\n---\n\n-   [HTTP/1.1 协议的性能问题](https://xiaolincoding.com/network/2_http/http2.html#http-1-1-%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98)\n    \n-   [兼容 HTTP/1.1](https://xiaolincoding.com/network/2_http/http2.html#%E5%85%BC%E5%AE%B9-http-1-1)\n    \n-   [头部压缩](https://xiaolincoding.com/network/2_http/http2.html#%E5%A4%B4%E9%83%A8%E5%8E%8B%E7%BC%A9)\n          压缩、避免重复、二进制编码（huffman）---HPACK算法\n    -   [静态表编码](https://xiaolincoding.com/network/2_http/http2.html#%E9%9D%99%E6%80%81%E8%A1%A8%E7%BC%96%E7%A0%81)\n         ![](lecture-note/Pasted%20image%2020230426144450.png)\n         ![](lecture-note/Pasted%20image%2020230426144715.png)\n         ![](lecture-note/Pasted%20image%2020230426144740.png)\n            \n\t    -   server` 头部字段的 Index 为 54，二进制为 110110，再加上固定 01\n            -  第二个字节为 `10000110`，首位比特位为 1 就代表 Value 字符串是经过 Huffman 编码的，经过 Huffman 编码的 Value 长度为 6\n            -  字符串 `nghttpx` 中每个字符对应的 Huffman 编码\n                 ![](lecture-note/Pasted%20image%2020230426145008.png)\n                 ![](lecture-note/Pasted%20image%2020230426145404.png)\n                 \n    -   [动态表编码](https://xiaolincoding.com/network/2_http/http2.html#%E5%8A%A8%E6%80%81%E8%A1%A8%E7%BC%96%E7%A0%81)\n         -   **必须同一个连接上，重复传输完全相同的 HTTP 头部**\n         -  Web 服务器提供 `http2_max_requests` 限制一个连接传输的请求数量，避免动态表无限增大，到达上限后，关闭 HTTP/2 连接来释放内存\n-   [二进制帧](https://xiaolincoding.com/network/2_http/http2.html#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%A7)\n    -  ![](lecture-note/Pasted%20image%2020230426145950.png)\n    - ![](lecture-note/Pasted%20image%2020230426150142.png)\n         - ![](lecture-note/Pasted%20image%2020230426150824.png)\n         -  **标志位**，可以保存 8 个标志位，用于携带简单的控制信息，比如：\n         -   **END_HEADERS** 表示头数据结束标志，相当于 HTTP/1 里头后的空行（“\\r\\n”）；\n         -   **END_Stream** 表示单方向数据发送结束，后续不会再有数据帧。\n         -  **PRIORITY** 流的优先级；\n         -   **流标识符**（Stream ID），最高位用，只有 31 位可以使用，最大值 2^31，约 21 亿，标识该 Frame 属于哪个 Stream，接收方根据相同 Stream ID 的帧，有序组装\n         -  **帧数据**: **HPACK 算法**压缩的HTTP 头部和包体\n-   [并发传输](https://xiaolincoding.com/network/2_http/http2.html#%E5%B9%B6%E5%8F%91%E4%BC%A0%E8%BE%93)\n    -  HTTP/2 **多个 Stream 复用一条 TCP 连接，达到并发的效果**\n          ![](lecture-note/Pasted%20image%2020230426151624.png)\n          \n\t-  多个 Stream 跑在一条 TCP 连接，同一个 HTTP 请求与响应是跑在同一个 Stream 中，HTTP 消息可以由多个 Frame 构成， 一个 Frame 可以由多个 TCP 报文构成  \n\t- **双方都可以建立 Stream**，服务端可以主动， 客户端奇，服务器偶\n\t- **HTTP/2 实现 100 个并发 Stream 时，建立一次 TCP 连接，HTTP/1.1 要 100 个\n\t- 每个 Stream 设置不同**优先级**，帧头中的「标志位」\n-   [服务器主动推送资源](https://xiaolincoding.com/network/2_http/http2.html#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%BB%E5%8A%A8%E6%8E%A8%E9%80%81%E8%B5%84%E6%BA%90)\n  -  客户端奇数Stream，服务器偶：\n        -  推送时，通过 `PUSH_PROMISE` 帧传输 HTTP 头部，帧中 `Promised Stream ID` 字段告知客户端，接下来会在哪个偶数号 Stream 中发送包体\n               ![](lecture-note/Pasted%20image%2020230426152643.png)\n               \n-   [总结](https://xiaolincoding.com/network/2_http/http2.html#%E6%80%BB%E7%BB%93)\n     - HTTP/2 是基于 TCP :字节流协议---完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用---- HTTP/2 队头阻塞问题\n     - 解决方案: 放弃 TCP 协议，使用 UDP 协议作为传输层协议-----HTTP/3","id":"06b44219c984d504","x":1790,"y":2022,"width":630,"height":818},
		{"type":"text","text":"-   [美中不足的 HTTP/2](https://xiaolincoding.com/network/2_http/http3.html#%E7%BE%8E%E4%B8%AD%E4%B8%8D%E8%B6%B3%E7%9A%84-http-2)\n    -   ![](lecture-note/Pasted%20image%2020230426154644.png)\n    -   [队头阻塞](https://xiaolincoding.com/network/2_http/http3.html#%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E)\n    -   [TCP 与 TLS 的握手时延迟](https://xiaolincoding.com/network/2_http/http3.html#tcp-%E4%B8%8E-tls-%E7%9A%84%E6%8F%A1%E6%89%8B%E6%97%B6%E5%BB%B6%E8%BF%9F)\n         -  TCP 三次握手和 TLS 四次握手（TLS 1.2）,3 个 RTT\n         -   TCP 「慢启动」\n    -   [网络迁移需要重新连接](https://xiaolincoding.com/network/2_http/http3.html#%E7%BD%91%E7%BB%9C%E8%BF%81%E7%A7%BB%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E8%BF%9E%E6%8E%A5)\n         -  一个 TCP 连接是由四元组确定 \n         -   解决：UDP（简单、不可靠、不需要连接 ）\n             -   ![](lecture-note/Pasted%20image%2020230426155040.png)   \n-   [QUIC 协议的特点](https://xiaolincoding.com/network/2_http/http3.html#quic-%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E7%82%B9)\n    -   [无队头阻塞](https://xiaolincoding.com/network/2_http/http3.html#%E6%97%A0%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E)\n         -  保证数据包的可靠性：序号唯一标识 \n         - QUIC 连接上的多个 Stream 之间无依赖，某个流丢包，只会影响该流 \n    -   [更快的连接建立](https://xiaolincoding.com/network/2_http/http3.html#%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B)\n         - QUIC 内部包含了 TLS 1.3，1 个 RTT ，「同时」完成建立连接与密钥协商，第二次连接 数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，0-RTT \n    -   [连接迁移](https://xiaolincoding.com/network/2_http/http3.html#%E8%BF%9E%E6%8E%A5%E8%BF%81%E7%A7%BB)\n         - **连接 ID** 标记通信两端\n-   [HTTP/3 协议](https://xiaolincoding.com/network/2_http/http3.html#http-3-%E5%8D%8F%E8%AE%AE)\n     -  ![](lecture-note/Pasted%20image%2020230426155904.png)\n     - QPACK 也采用了静态表（91项）、动态表及 Huffman 编码\n         -  HTTP/2 和 HTTP/3 的 Huffman 编码没多大不同，动态表编解码方式不同 \n             - 问题：动态表有时序性：首次请求丢包，后续请求无法解码HPACK 头部（没建立好动态表），阻塞到首次请求中丢失的数据包重传过来\n             - QPACK 解决：两个特殊的单向流**同步双方的动态表**\n                  -  QPACK Encoder Stream：将一个字典（Key-Value）传递给对方 \n                  -  QPACK Decoder Stream，响应对方字典已更新到自己的本地动态表\n    \n-   [总结](https://xiaolincoding.com/network/2_http/http3.html#%E6%80%BB%E7%BB%93)\n","id":"4d7a7b9c07b0c7ae","x":2614,"y":2126,"width":853,"height":634},
		{"type":"text","text":" HTTPS 如何优化？\n\n---\n\n-   [分析性能损耗](https://xiaolincoding.com/network/2_http/https_optimize.html#%E5%88%86%E6%9E%90%E6%80%A7%E8%83%BD%E6%8D%9F%E8%80%97)\n          第一个环节， TLS 协议握手；\n          第二个环节，握手后的对称加密报文传输 ![](lecture-note/Pasted%20image%2020230425140347.png)\n-   [硬件优化](https://xiaolincoding.com/network/2_http/https_optimize.html#%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%96)\n          **HTTPS 协议是计算密集型，而不是 I/O 密集型**，所以买**支持 AES-NI 特性的 CPU**\n-   [软件优化](https://xiaolincoding.com/network/2_http/https_optimize.html#%E8%BD%AF%E4%BB%B6%E4%BC%98%E5%8C%96)\n          **软件升级**，**协议优化**\n-   [协议优化](https://xiaolincoding.com/network/2_http/https_optimize.html#%E5%8D%8F%E8%AE%AE%E4%BC%98%E5%8C%96)\n    -   [密钥交换算法优化](https://xiaolincoding.com/network/2_http/https_optimize.html#%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96)\n              **选用 ECDHE 密钥交换**算法替换 RSA 算法\n              **选择 x25519 曲线**\n               **AES_128_GCM**\n    -   [TLS 升级](https://xiaolincoding.com/network/2_http/https_optimize.html#tls-%E5%8D%87%E7%BA%A7)\n              TLS1.3： \n                  合并Hello 和公钥交换，1 RTT\n                  密钥交换算法只支持 ECDHE 算法**\n-   [证书优化](https://xiaolincoding.com/network/2_http/https_optimize.html#%E8%AF%81%E4%B9%A6%E4%BC%98%E5%8C%96)\n    -   [证书传输优化](https://xiaolincoding.com/network/2_http/https_optimize.html#%E8%AF%81%E4%B9%A6%E4%BC%A0%E8%BE%93%E4%BC%98%E5%8C%96)\n          **选择椭圆曲线（ECDSA）证书**\n    -   [证书验证优化](https://xiaolincoding.com/network/2_http/https_optimize.html#%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81%E4%BC%98%E5%8C%96)\n          CRL\n          OCSP:看网络\n          OCSP Stapling:  服务器向 CA 周期性查询证书状态，获得带有时间戳和签名的响应结果并缓存它\n-   [会话复用](https://xiaolincoding.com/network/2_http/https_optimize.html#%E4%BC%9A%E8%AF%9D%E5%A4%8D%E7%94%A8)\n    -   [Session ID](https://xiaolincoding.com/network/2_http/https_optimize.html#session-id)\n           -   服务器的内存压力大\n           -   客户端再次连接不一定会命中上次访问过的服务器**，还要走完整的 TLS 握手\n    -   [Session Ticket](https://xiaolincoding.com/network/2_http/https_optimize.html#session-ticket)\n           -   要确保每台服务器加密 「会话密钥」的密钥是一致的\n           -   Session ID 和 Session Ticket **都不具备前向安全性**\n           -   避免重放攻击：**对会话密钥设定一个合理的过期时间**\n    -   [Pre-shared Key](https://xiaolincoding.com/network/2_http/https_optimize.html#pre-shared-key)\n-   [总结](https://xiaolincoding.com/network/2_http/https_optimize.html#%E6%80%BB%E7%BB%93)","id":"32b647a6d51406f2","x":4040,"y":980,"width":620,"height":896},
		{"type":"text","text":"HTTP/1.1 如何优化？\n\n---\n\n-   [如何避免发送 HTTP 请求？](https://xiaolincoding.com/network/2_http/http_optimize.html#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%8F%91%E9%80%81-http-%E8%AF%B7%E6%B1%82)\n        缓存: 客户端把第一次请求以及响应的数据保存在本地磁盘上    【 URL 作为 key，响应value】\n        etag\n-   [如何减少 HTTP 请求次数？](https://xiaolincoding.com/network/2_http/http_optimize.html#%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91-http-%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0)\n    -   [减少重定向请求次数](https://xiaolincoding.com/network/2_http/http_optimize.html#%E5%87%8F%E5%B0%91%E9%87%8D%E5%AE%9A%E5%90%91%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0)\n           `302` 响应码和 `Location` 头部\n           **重定向的工作交由代理服务器完成**\n    -   [合并请求](https://xiaolincoding.com/network/2_http/http_optimize.html#%E5%90%88%E5%B9%B6%E8%AF%B7%E6%B1%82)\n          **小图片合并成一个大图片**:\n                CSS Image Sprites\n                服务端使用 `webpack`\n                图片的二进制数据用 base64 编码后，以 URL 的形式嵌入到 HTML 文件，跟随 HTML 文件一并发送\n    -   [延迟发送请求](https://xiaolincoding.com/network/2_http/http_optimize.html#%E5%BB%B6%E8%BF%9F%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82)\n-   [如何减少 HTTP 响应的数据大小？](https://xiaolincoding.com/network/2_http/http_optimize.html#%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91-http-%E5%93%8D%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B0%8F)\n    -   [无损压缩](https://xiaolincoding.com/network/2_http/http_optimize.html#%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9)\n           Accept-Encoding: gzip, deflate, br\n           Content-Encoding: gzip\n    -   [有损压缩](https://xiaolincoding.com/network/2_http/http_optimize.html#%E6%9C%89%E6%8D%9F%E5%8E%8B%E7%BC%A9)\n           Accept: audio/*; q=0.2, audio/basic\n            Google 推出的 **WebP 格式**","id":"b123858dcf0add0f","x":1790,"y":280,"width":540,"height":706},
		{"type":"text","text":"- ![](lecture-note/Pasted%20image%2020230423163639.png)\n- 两点之间【服务器】\n     - ![](lecture-note/Pasted%20image%2020230423164408.png)\n- 常见字段\n    - `Host` 字段：将请求发往「同一台」服务器上的不同网站\n    - `Content-Length` 字段，表明本次回应的数据长度\n         -  HTTP 是基于 TCP 传输协议进行通信的,“粘包”问题，   **HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题**[如何理解是 TCP 面向字节流协议？](https://xiaolincoding.com/network/3_tcp/tcp_stream.html)\n    - Connection: Keep-Alive\n         - [TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？](https://xiaolincoding.com/network/3_tcp/tcp_http_keepalive.html)\n     -  Content-Type: text/html; Charset=utf-8\n     - Accept: */*\n     - Content-Encoding: gzip \n     - Accept-Encoding: gzip, deflate\n- GET 与 POST\n    - GET 语义：从服务器获取指定的资源：ASCII+长度限制\n    - POST 语义：根据请求负荷（报文body）对指定的资源做出处理\n- 缓存： \n    -  强：浏览器判断没过期就用本地缓存：from disk cache\n        - HTTP 响应头部：\n             - `Cache-Control`， 相对时间，优先级高\n             - `Expires`，绝对时间\n    - 协商缓存：服务端告知客户端是否可以使用缓存\n        - ![](lecture-note/Pasted%20image%2020230423170511.png)\n        -  请求头部中的 `If-Modified-Since` 字段与响应头部中的 `Last-Modified`\n        -  请求头部中的 `If-None-Match` 字段与响应头部中的 `ETag`（优先级高：没修改last modify也可能变、秒级、修改时间）\n         - 都要配合强缓存的cache-control\n             - ![](lecture-note/Pasted%20image%2020230423171740.png)\n- HTTP 特点：\n    - 优点：「简单、灵活和易于扩展、应用广泛和跨平台」\n    - 缺点：「无状态（cookie）、明文传输」，同时还有一大缺点「不安全」（窃听篡改伪装）\n     - HTTP1.0性能：TCP连接问题:长连接---pipeline(解决请求队头堵塞，非默认开启)\n    - HTTP&HTTPS：\n         - 区别：\n             - 在 TCP 和 HTTP 网络层之间加入了 SSL/TLS（又握手）、443/80、CA\n             - 信息加密、校验、身份证书\n             - 混合加密：对称+非对称\n             - 摘要算法+数字签名：哈希值（保证不被篡改不保证不被替换（非对称：公钥（传输安全）+私钥（不被冒充，对哈希值））\n             - 数字证书（服务器公钥）：![](lecture-note/Pasted%20image%2020230423180138.png)\n- HTTPS建立连接：\n     -  基于RSA算法：的TLS握手    ![](lecture-note/Pasted%20image%2020230423180544.png)\n          -  [HTTPS RSA 握手解析](https://xiaolincoding.com/network/2_http/https_rsa.html)\n              - 「前向安全」的问题：如果服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解:\n              -  解决：(ECDHE)[HTTPS ECDHE 握手解析](https://xiaolincoding.com/network/2_http/https_ecdhe.html#%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0)\n             -  客户端校验数字证书的流程：![](lecture-note/Pasted%20image%2020230423184037.png)\n              - 根证书信任链：**确保根证书的绝对安全性，将根证书隔离地越严格越好**![](lecture-note/Pasted%20image%2020230423184511.png)\n        - HTTPS 的应用数据是如何保证完整性\n             - TLS 在实现上分为**握手协议**和**记录协议**：\n                  - TLS 四次握手：协商加密算法和生成对称密钥，保护应用程序数据（即 HTTP 数据）\n                  - 记录协议：完整性和来源，对 HTTP 数据加密，![](lecture-note/Pasted%20image%2020230423185044.png)\n            -  记录协议完成后，最终的报文数据将传递到传输控制协议 (TCP) 层进行传输\n                 -  [理解SSL/TLS系列 (四) 记录协议](https://blog.csdn.net/zhanyiwp/article/details/105627799)\n        - HTTPS 一定安全可靠吗\n            - ![](lecture-note/Pasted%20image%2020230423185401.png)\n             - HTTPS 协议本身到目前为止没有任何漏洞的，即使你成功进行中间人攻击，是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全\n              - 抓包工具能够抓包的关键是客户端会往系统受信任的根证书列表中导入抓包工具生成的证书，而这个证书会被浏览器信任，也就是抓包工具给自己创建了一个认证中心 CA，客户端拿着中间人签发的证书去中间人自己的 CA 去认证，当然认为这个证书是有效的\n                  - 如何避免被中间人抓取数据?\n                     - **HTTPS 双向认证**:    ![](lecture-note/Pasted%20image%2020230424153347.png)\n    - HTTP1.1： 长连接+pipeline  VS   头部未压缩、头部冗长、服务器顺序相应、无优先级、服务器被动\n    - HTTP2：安全（HTTPS） 头部压缩（hpack:头信息表，索引号）、二进制格式（头信息帧+数据帧、静态表：[HTTP/2 牛逼在哪？](https://xiaolincoding.com/network/2_http/http2.html)）、并发传输（N stream【ID，有序组装】（N massage（N fream））复用一条TCP连接）、服务器主动   VS  还是队头阻塞（TCP：字节流协议，有序，丢包出发重传机制）\n      - ![](lecture-note/Pasted%20image%2020230424154944.png)\n       - ![](lecture-note/Pasted%20image%2020230424155348.png)\n       - HTTP3： ![](lecture-note/Pasted%20image%2020230424160906.png)\n        -  UDP：无顺序，不可靠---基于此的QUIC：\n              -  无队头阻塞、\n             - 快速连接（QUIC 协议（包含TLS/1.3）握手，第一次1 RTT（确认双方「连接 ID」）），第二次0RTT（连接信息+TLS信息）、\n              - 连接迁移（基于 TCP 的 HTTP 通过四元组确定一条 TCP 连接，QUIC 通过**连接 ID** 标记通信的两个端点）\n         - QUIC 是一个在 UDP 之上的**伪** TCP + TLS + HTTP/2 的多路复用的协议![](lecture-note/Pasted%20image%2020230424162457.png)\n ","id":"64c78268aa35a6c9","x":2037,"y":1200,"width":850,"height":713},
		{"type":"text","text":"![](lecture-note/Pasted%20image%2020230422220548.png)\n![](lecture-note/Pasted%20image%2020230422220849.png)\nIP包（MTU:1500字节---分片【网络层】---分包多，吞吐量小）\nLINUX协议栈：\n     ![](lecture-note/Pasted%20image%2020230422221408.png)\n     LINUX接收包：\n           ![](lecture-note/Pasted%20image%2020230422223237.png)\n            网卡（DMA）---ring buffer---触发CPU中断告诉操作系统（linux2.6---NAPI（中断+轮询：poll））---CPU：中断处理函数（中断表）---屏蔽/软：内核线程的ksoftirqd线程---轮询数据：从ring buffer 取数据帧:sk_buff 作为网络包给网络协议栈：接口层（合法？）---上层协议（IPV4/V6？）---网络层（本机：上层协议（TCP/UDP？））---传输层（四元组---socket缓冲区）---应用层（YYC缓冲区）---用户进程\n             sk_buff 可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层我们称为 segment，在 IP 层我们叫 packet，在数据链路层称为 frame\n     发送：系统调用socket(内核态)--sk_buff（发送缓存区） ---TCP(copy【这个副本在收到ACK后删除】，TCP头)---网络层---接口层--软中断,驱动程序（发送队列）---ringbuffer---DMA(网卡)---内存清理（网卡---硬中断）---TCP(ACK)释放原始sk_buff,ringbuffer\n     发送网络数据的时候，涉及3次内存拷贝操作\n          sk_buff内核态，发送缓存区； TCP copy（ACK）；\n          IP（>MTU）","id":"3a5f6b7ac0a4fe02","x":1040,"y":980,"width":750,"height":760},
		{"type":"text","text":"既然有 HTTP 协议，为什么还要有 WebSocket？\n\n---\n\n-   [使用 HTTP 不断轮询](https://xiaolincoding.com/network/2_http/http_websocket.html#%E4%BD%BF%E7%94%A8-http-%E4%B8%8D%E6%96%AD%E8%BD%AE%E8%AF%A2)\n    -  问题：\n         -  消耗带宽\n         -  卡顿\n-   [长轮询](https://xiaolincoding.com/network/2_http/http_websocket.html#%E9%95%BF%E8%BD%AE%E8%AF%A2)\n    -  **将超时设置的很大** ，例如消息队列 RocketMQ 中，消费者去取数据时\n-   [WebSocket是什么](https://xiaolincoding.com/network/2_http/http_websocket.html#websocket%E6%98%AF%E4%BB%80%E4%B9%88)  **全双工**，1.1半双工----**基于TCP的新协议**\n    -   [怎么建立WebSocket连接](https://xiaolincoding.com/network/2_http/http_websocket.html#%E6%80%8E%E4%B9%88%E5%BB%BA%E7%AB%8Bwebsocket%E8%BF%9E%E6%8E%A5)\n        -  header:  \n            - （Connection: Upgrade），(Upgrade: WebSocket）,随机生成的 base64 码（Sec-WebSocket-Key），发给服务器。\n            - 服务器：\n                 -  `HTTP/1.1 101 Switching Protocols\\r\\n\n                 -  Sec-WebSocket-Accept: iBJKv/ALIW2DobfoA4dmr3JHBCY=\\r\\n\n                 -  Upgrade: WebSocket\\r\\n\n                 -  Connection: Upgrade\\r\\n`\n    -   [WebSocket抓包](https://xiaolincoding.com/network/2_http/http_websocket.html#websocket%E6%8A%93%E5%8C%85)\n        -  ![](lecture-note/Pasted%20image%2020230426170539.png)\n        - **三次TCP握手之后，利用 HTTP 协议升级为 WebSocket**,**升级完成之后就跟HTTP没有任何关系**\n    -   [WebSocket的消息格式](https://xiaolincoding.com/network/2_http/http_websocket.html#websocket%E7%9A%84%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F)\n        -  数据包在WebSocket中被叫做**帧**![](lecture-note/Pasted%20image%2020230426170931.png)\n        - **opcode字段**：**什么类型**\n             -   1 text（string）\n             -   2 二进制（[]byte）\n             -   8 关闭连接\n        -  **payload字段**：数据的长度，单位**字节**\n            -  **先读最先的7个bit**，根据它的取值决定还要不要再读个 16bit 或 64bit。\n                -  0~125\n                - 126（0x7E）\n                - 127（0x7F）\n        -  **payload data字段**\n    -   [WebSocket的使用场景](https://xiaolincoding.com/network/2_http/http_websocket.html#websocket%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF)\n        -  **需要服务器和客户端（浏览器）频繁交互** \n-   [总结](https://xiaolincoding.com/network/2_http/http_websocket.html#%E6%80%BB%E7%BB%93)","id":"35dc83315a5c7d3c","x":3120,"y":1240,"width":700,"height":676},
		{"type":"text","text":"TCP 三次握手与四次挥手面试题\n\n---\n\n-   [TCP 基本认识](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86)\n    -   [TCP 头格式有哪些？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E5%A4%B4%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B)\n        -  ![](lecture-note/Pasted%20image%2020230426172530.png) \n    -   [为什么需要 TCP 协议？ TCP 工作在哪一层？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-tcp-%E5%8D%8F%E8%AE%AE-tcp-%E5%B7%A5%E4%BD%9C%E5%9C%A8%E5%93%AA%E4%B8%80%E5%B1%82)\n        -  TCP 是一个工作在**传输层**的**可靠**数据传输的服务，它能确保接收端接收的网络包是**无损坏、无间隔、非冗余和按序的** \n    -   [什么是 TCP ？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%BB%80%E4%B9%88%E6%98%AF-tcp)\n        - **面向连接的、可靠的、基于字节流**的传输层通信协议 \n    -   [什么是 TCP 连接？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%BB%80%E4%B9%88%E6%98%AF-tcp-%E8%BF%9E%E6%8E%A5)\n        -  **用于保证可靠性和流量控制维护的某些状态信息组合，包括 Socket( IP 地址和端口号)、序列号和窗口大小称为连接** \n    -   [如何唯一确定一个 TCP 连接呢？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E5%A6%82%E4%BD%95%E5%94%AF%E4%B8%80%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%AA-tcp-%E8%BF%9E%E6%8E%A5%E5%91%A2)\n        -  源/目的地址（32 位） IP 头部，通过 IP 协议发送报文给对方主机。\n        - 源/目的端口（16 位） TCP 头部，告诉 TCP 协议把报文发给哪个进程。 \n        -  有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是多少\n            -  ![](lecture-note/Pasted%20image%2020230426173425.png)\n            - **文件描述符限制**，每个 TCP 连接都是一个文件\n            - **内存限制**OOM\n    -   [UDP 和 TCP 有什么区别呢？分别的应用场景是？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#udp-%E5%92%8C-tcp-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2-%E5%88%86%E5%88%AB%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF)\n        -  ![](lecture-note/Pasted%20image%2020230426175256.png)\n        - **TCP 和 UDP 区别**:\n            - 连接\n            -  TCP 1V1, UDP: NVN\n            - 可靠性\n            - UDP应用层实现QUIC，尽量可靠\n            - UDP没有拥塞流量控制\n            - TCP首部长，UDP8字节\n            - TCP流式传输：无边界，可靠、UDP包：丢包乱序\n            - TCP>MSS,传输层分片、 分片丢了重传分片；UDP>MTV,IP层分片，组装完给tcp层\n        -  应用场景：\n            - TCP: FTP文件传输、HHTP/HTTPS \n            - UDP: DNS/SNMP/视频音频广播\n        -  为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有\n            - UDP 头部长度则是**不会变化**\n        -  为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有\n            - ![](lecture-note/Pasted%20image%2020230426180322.png)\n            - 为了补全 UDP 首部长度是 `4` 字节的整数倍，才补充了「包长度」\n            - 如今的 UDP 协议是基于 IP 协议发展的，而当年可能并非如此\n    -   [TCP 和 UDP 可以使用同一个端口吗？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E5%92%8C-udp-%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%90%97)\n        -  传输层「端口号」区分同一个主机上不同应用程序的数据包 \n        -  ![](lecture-note/Pasted%20image%2020230426180836.png)\n        - [TCP 和 UDP 可以使用同一个端口吗？](https://xiaolincoding.com/network/3_tcp/port.html)\n-   [TCP 连接建立](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B)\n    -   [TCP 三次握手过程是怎样的？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84)\n        -   `CLOSE` 、服务端主动监听某个端口， `LISTEN` \n        -  客户端（`client_isn`）「序号」， `SYN` 为 `1`  客户端 `SYN-SENT`\n        -  （`server_isn`）「序号」「确认应答号」： `client_isn + 1`,  `SYN` 和 `ACK` ：为 `1`，服务端处于 `SYN-RCVD` 状态。\n        -   客户端`ACK` ：为 `1` ，「确认应答号」： `server_isn + 1` ，携带数据 `ESTABLISHED`\n        -  服务端`ESTABLISHED`\n    -   [如何在 Linux 系统中查看 TCP 状态？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E5%A6%82%E4%BD%95%E5%9C%A8-linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%9F%A5%E7%9C%8B-tcp-%E7%8A%B6%E6%80%81)\n        - netstat -napt \n    -   [为什么是三次握手？不是两次、四次？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E3%80%81%E5%9B%9B%E6%AC%A1)\n        -  阻止重复历史连接的初始化（主要原因）\n            - 客户端收到服务器对旧的SYN中SEQ_NUM的应答ACK_NUM=旧+1，之后RST断开连接   \n            - **两次握手连接，**服务端没有中间状态**无法阻止历史连接**\n        - 同步双方的初始序列号\n            -  序列号作用：\n                - 去除重复数据\n                - 按序接收\n                - 标识被接受的数据包\n        - 避免资源浪费\n            -  没有第三次握手，服务端不清楚客户端是否收到了自己回复的 `ACK` 报文，所以服务端每收到一个 `SYN` 就只能先主动建立一个连接\n    -   [为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%8F%E6%AC%A1%E5%BB%BA%E7%AB%8B-tcp-%E8%BF%9E%E6%8E%A5%E6%97%B6-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%BA%8F%E5%88%97%E5%8F%B7%E9%83%BD%E8%A6%81%E6%B1%82%E4%B8%8D%E4%B8%80%E6%A0%B7%E5%91%A2)\n        -   防止历史报文被下一个相同四元组的连接接收（主要方面）\n             - 序列号和初始化序列号会回绕---无法根据判断新老数据\n                 -  tcp_timestamps 默认开启，TCP 头部使用时间戳，便于精确计算 RTT ，防止序列号回绕（PAWS） \n                      -  防回绕序列号算法: 连接双方维护（Recent TSval），收到一个新数据包时间戳值跟 Recent TSval 比较，**发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，丢弃数据包** \n                      -  时间戳也回绕了怎么办？\n                        - 时间戳大小 32 bit,回绕速度只与对端主机时钟频率有关 \n                        - 扩大到64bit\n                        - 将一个与时钟频率无关的值作为时间戳\n        -   防止黑客伪造的相同序列号的 TCP 报文被对方接收 \n        -   [TCP 是如何避免历史报文的？](https://xiaolincoding.com/network/3_tcp/isn_deff.html)\n    -   [初始序列号 ISN 是如何随机产生的？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7-isn-%E6%98%AF%E5%A6%82%E4%BD%95%E9%9A%8F%E6%9C%BA%E4%BA%A7%E7%94%9F%E7%9A%84)\n        -  RFC793 提到初始化序列号 ISN 随机生成算法：ISN = M + F(localhost, localport, remotehost, remoteport) \n            -   `M` 是一个计时器，每隔 4 微秒加 1。\n            -   `F` ：Hash 算法，根据四元组生成一个随机数值。 MD5 算法\n    -   [既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E6%97%A2%E7%84%B6-ip-%E5%B1%82%E4%BC%9A%E5%88%86%E7%89%87-%E4%B8%BA%E4%BB%80%E4%B9%88-tcp-%E5%B1%82%E8%BF%98%E9%9C%80%E8%A6%81-mss-%E5%91%A2)\n        -  ![](lecture-note/Pasted%20image%2020230426184446.png)\n        - **当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传**\n            -  接收方的 IP 层无法组装完整的 TCP 报文（头部 + 数据）送到 TCP 层，不会响应 ACK ，发送方收不到 ACK 触发超时重传 \n        -  TCP 层分片后，一个分片丢失，重发时也是以 MSS 为单位,而不用重传所有的分片\n    -   [第一次握手丢失了，会发生什么？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88)\n        -  客户端收不到 SYN-ACK 报文「超时重传」重传 SYN 报文，序列号一样\n        -   最大重传次数由 `tcp_syn_retries`  5\n        - **每次超时的时间是上一次的 2 倍**，大约 1 分钟\n    -   [第二次握手丢失了，会发生什么？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88)\n        -  客户端会重传 SYN 报文， `tcp_syn_retries` \n        -  服务端重传 SYN-ACK 报文**  `tcp_synack_retries ` 5\n        -   ![](lecture-note/Pasted%20image%2020230426185602.png)\n        - \n    -   [第三次握手丢失了，会发生什么？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88)\n        -  **ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文** \n        -   服务端重传 SYN-ACK 达到最大重传次数，再等待一段时间（时间为上一次超时时间的 2 倍），还没收到断开连接\n    -   [什么是 SYN 攻击？如何避免 SYN 攻击？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%BB%80%E4%B9%88%E6%98%AF-syn-%E6%94%BB%E5%87%BB-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D-syn-%E6%94%BB%E5%87%BB)\n        -  TCP 三次握手，Linux 内核维护两个队列：\n        - ![](lecture-note/Pasted%20image%2020230427145205.png)\n        - 把 TCP 半连接队列打满，后续收到 SYN 报文会丢弃**，客户端无法和服务端建立连接\n        - 解决：\n            -  调大 netdev_max_backlog；--网卡接收数据包的速度大于内核处理的速度时，保存到队列\n            -   增大 TCP 半连接队列\n                -   增大 net.ipv4.tcp_max_syn_backlog\n                -  增大 listen() 函数中的 backlog\n                -  增大 net.core.somaxconn \n            - 开启 tcp_syncookies；---不使用 SYN 半连接队列下建立连接\n                -   0,1,2  ![](lecture-note/Pasted%20image%2020230427151415.png)\n                \n            - 减少 SYN+ACK 重传次数---大量处于 SYN_REVC 状态的 TCP 连接\n                 -  `tcp_synack_retries` \n-   [TCP 连接断开](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E8%BF%9E%E6%8E%A5%E6%96%AD%E5%BC%80)\n    -   [TCP 四次挥手过程是怎样的？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84)\n         -  ![](lecture-note/Pasted%20image%2020230427151725.png)\n         - \n    -   [为什么挥手需要四次？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8C%A5%E6%89%8B%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1)\n         -  服务端要等待完成数据的发送和处理，`ACK` 和 `FIN` 分开发送，需要四次挥手 \n         -   [TCP 四次挥手，可以变成三次吗？](https://xiaolincoding.com/network/3_tcp/tcp_three_fin.html)\n    -   [第一次挥手丢失了，会发生什么？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88)\n         -  ![](lecture-note/Pasted%20image%2020230427152148.png) \n    -   [第二次挥手丢失了，会发生什么？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88)\n          -  ![](lecture-note/Pasted%20image%2020230427152306.png)\n          - 调用 close 关闭的连接，如果在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭\n              ![](lecture-note/Pasted%20image%2020230427152450.png)\n        -  使用 shutdown 函数关闭连接，指只关闭发送方向,还是可以接收数据 ![](lecture-note/Pasted%20image%2020230427152614.png)\n    -   [第三次挥手丢失了，会发生什么？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88)\n        -  ![](lecture-note/Pasted%20image%2020230427152833.png)\n        -   服务端达到了重传最大次数，等一段时间没收到第四次挥手断开连接。\n        -   客户端通过 close 关闭连接， tcp_fin_timeout 时间内没收到第三次挥手断开连接\n    -   [第四次挥手丢失了，会发生什么？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88)\n         -   ![](lecture-note/Pasted%20image%2020230427154030.png)\n         - 服务端重传,到次数断开\n         -  客户端 TIME_WAIT 状态，开启 2MSL 的定时器，再收到第三次挥手重置， 2MSL 时长后断开连接\n    -   [为什么 TIME_WAIT 等待的时间是 2MSL？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88-time-wait-%E7%AD%89%E5%BE%85%E7%9A%84%E6%97%B6%E9%97%B4%E6%98%AF-2msl)\n         -  **MSL 应该要大于等于 TTL 消耗为 0 的时间**，确保报文已被自然消亡\n         -  **TTL ： 64，MSL ： 30 秒， Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，超过认为报文消失在网络中**\n         -  **一来一回需要等待 2 倍的时间**\n         -  **至少允许报文丢失一次**\n         -  **Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒**。\n    -   [为什么需要 TIME_WAIT 状态？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-time-wait-%E7%8A%B6%E6%80%81)\n         -   防止历史连接中的数据，被后面相同四元组的连接错误的接收；\n             -  **序列号：一个 32 位的无符号数，到达 4G 之后回到 0**\n             -   **初始化序列号：一个 32 位的计数器，每 4 微秒加 1，循环一次需要 4.55 小时**\n             -   TCP   TIME_WAIT 状态`2MSL` 时长，**足以让两个方向上的数据包都被丢弃，再出现的数据包一定都是新建立连接所产生的**\n             - **无法根据序列号来判断新老数据**\n         -   保证「被动关闭连接」的一方，能被正确的关闭\n            -  ![](lecture-note/Pasted%20image%2020230427161152.png) \n    -   [TIME_WAIT 过多有什么危害？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#time-wait-%E8%BF%87%E5%A4%9A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3)\n        -   **客户端（主动关闭连接方）的 TIME_WAIT 状态过多**，占满端口资源，无法对「目的 IP+ 目的 PORT」都一样的服务端发起连接了，但被使用的端口，可以继续对另外一个服务端发起连接的。：[客户端的端口可以重复使用吗？](https://xiaolincoding.com/network/3_tcp/port.html#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%A4%8D%E4%BD%BF%E7%94%A8%E5%90%97) \n        -   **服务端（主动关闭连接方）不会导致端口资源受限，因为服务端只监听一个端口，而一个四元组唯一确定一个 TCP 连接，服务端可以建立很多连接，但是TCP 连接过多占用系统资源：文件描述符、内存资源、CPU 资源、线程资源\n    -   [如何优化 TIME_WAIT？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-time-wait)\n         -    打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；\n            -  tcp_tw_reuse 只能用客户端（连接发起方）：\n                 -  开启了该功能调用 connect() 函数时，内核会随机找一个 time_wait 超过 1 秒的连接给新的连接复用\n                 - 前提：打开对 TCP 时间戳的支持\n                     -  `2MSL` 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃 \n                -  默认关闭：\n                      - 开启 tcp_tw_reuse 风险，因为快速复用 TIME_WAIT 状态的端口，导致新连接可能被回绕序列号的 RST 报文断开了，如果不跳过 TIME_WAIT 状态，而是停留 2MSL 时长，那么这个 RST 报文就不会出现下一个新的连接\n         -   net.ipv4.tcp_max_tw_buckets\n             -  默认： 18000，超过这个值系统将后面的 TIME_WAIT 连接状态重置** \n         -   程序中使用 SO_LINGER ，应用强制使用 RST 关闭 \n               ![](lecture-note/Pasted%20image%2020230427162535.png)\n         TIME_WAIT 是我们的朋友，它是有助于我们的，不要试图避免这个状态，而是应该弄清楚它\n         如果服务端要避免过多的 TIME_WAIT 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT\n    -   [服务器出现大量 TIME_WAIT 状态的原因有哪些？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8F-time-wait-%E7%8A%B6%E6%80%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B)\n         -   HTTP 没有使用长连接\n             -  请求响应头： Connection: Keep-Alive  1.1默认开启\n             -   Connection:close  \n                 -   不管哪一方禁用了 HTTP Keep-Alive，都由服务端主动关闭连接，服务端上就会出现 TIME_WAIT 状态的连接\n                     -  客户端禁用，不再重用这个连接的时机就只有在服务端了\n                     -  服务端禁用，服务端主动关闭只要调用一次 close() 剩下由内核 TCP 栈处理，一次 syscall；客户端关闭，则服务端在写完最后一个 response 之后把 socket 放入 readable 队列，调select / epoll 等待事件；调用 read() 知道连接关闭，两次 syscall， socket 保持时间也会更长\n         -   HTTP 长连接超时\n             -   nginx 启动「定时器」，没新请求，nginx 触发回调函数来关闭该连接，服务端出现 TIME_WAIT 状态连接\n             -   往网络问题的方向排查\n         -   HTTP 长连接的请求数量达到上限 \n             -  QPS 比较高， keepalive_requests 参数值是 100， nginx 频繁关闭连接，服务端上大量 TIME_WAIT 状态*\n    -   [服务器出现大量 CLOSE_WAIT 状态的原因有哪些？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8F-close-wait-%E7%8A%B6%E6%80%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B)\n        -  说明服务端的程序没有调用 close 函数关闭连接 \n        -  TCP 服务端的流程：\n            1.  创建服务端 socket，bind 绑定端口、listen 监听端口\n            2.  将服务端 socket 注册到 epoll：（没做，新连接到来时，服务端没办法感知并获取已连接的 socket对 socket 调用 close）\n            3.  epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket （没做）\n            4.  将已连接的 socket 注册到 epoll（没做，收到 FIN 报文的时候，服务端不知道）[一次 Netty 代码不健壮导致的大量 CLOSE_WAIT 连接原因分析](https://mp.weixin.qq.com/s?__biz=MzU3Njk0MTc3Ng==&mid=2247486020&idx=1&sn=f7cf41aec28e2e10a46228a64b1c0a5c&scene=21#wechat_redirect)\n            5.  epoll_wait 等待事件发生\n            6.  对方连接关闭时，我方调用 close（没做）\n            \n    -   [如果已经建立了连接，但是客户端突然出现故障了怎么办？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5-%E4%BD%86%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AA%81%E7%84%B6%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E)\n         -  TCP **保活机制** \n             -  考虑情况：\n                 -   对端程序是正常工作，正常响应，TCP 保活时间重置\n                 -   对端主机宕机并重启。对端可以响应，但没有该连接的有效信息，**产生一个 RST 报文**，发现 TCP 连接重置。\n                 -   对端主机宕机（不是进程崩溃：操作系统在回收进程资源的时候，会发送 FIN 报文，宕机则无法感知），或报文不可达。没有响应，达到保活探测次数TCP 会报告该 TCP 连接已经死亡\n    -   [如果已经建立了连接，但是服务端的进程崩溃会发生什么？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5-%E4%BD%86%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%B4%A9%E6%BA%83%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88)\n        -  内核回收该进程所有 TCP 连接资源，发送第一次挥手 FIN 报文，与客户端 TCP 四次挥手\n        -  [TCP 连接，一端断电和进程崩溃有什么区别？](https://xiaolincoding.com/network/3_tcp/tcp_down_and_crash.html)\n        -  [拔掉网线后， 原本的 TCP 连接还存在吗？](https://xiaolincoding.com/network/3_tcp/tcp_unplug_the_network_cable.html)\n-   [Socket 编程](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#socket-%E7%BC%96%E7%A8%8B)\n    -   [针对 TCP 应该如何 Socket 编程？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E9%92%88%E5%AF%B9-tcp-%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95-socket-%E7%BC%96%E7%A8%8B)\n         -  ![](lecture-note/Pasted%20image%2020230427170544.png)\n         -   服务端和客户端初始化 `socket`，得到文件描述符；\n         -    `bind`，将 socket 绑定在指定的 IP 地址和端口;\n         -    `listen`，`accept`，等待客户端连接；\n         -    `connect`，发起连接请求；\n         -   服务端 `accept` 返回用于传输的 `socket` 的文件描述符；\n         -   客户端 `write` ；服务端`read` ；\n         -   客户端 `close`，服务端 `read` 读取到了 `EOF`，处理完数据用 `close`\n    -   [listen 时候参数 backlog 的意义？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#listen-%E6%97%B6%E5%80%99%E5%8F%82%E6%95%B0-backlog-%E7%9A%84%E6%84%8F%E4%B9%89)\n         -  现在通常认为 backlog 是 accept 队列\n         -  accpet 队列长度 = min(backlog, somaxconn)\n    -   [accept 发生在三次握手的哪](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#accept-%E5%8F%91%E7%94%9F%E5%9C%A8%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%93%AA%E4%B8%80%E6%AD%A5)\n         -  ![](lecture-note/Pasted%20image%2020230427171312.png)\n         -  **客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后\n     -   [客户端调用 close 了，连接是断开的流程是什么？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B0%83%E7%94%A8-close-%E4%BA%86-%E8%BF%9E%E6%8E%A5%E6%98%AF%E6%96%AD%E5%BC%80%E7%9A%84%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88)\n         -  ![](lecture-note/Pasted%20image%2020230427173034.png)\n         -    服务端接收到了 FIN 报文，TCP 协议栈给其插文件结束符 `EOF` 到接收缓冲区中，应用程序可以通过 `read` 调用来感知这个 FIN 包。这个 `EOF` 会被**放在排队等候的其他已接收的数据后**，需要处理这种异常情况，因为 EOF 表示在该连接上再无额外数据到达。此时，服务端进入 CLOSE_WAIT 状态；\n         -   处理完数据后会读到 `EOF`，调用 `close` 关闭它的套接字，使服务端发 FIN 包，处于 LAST_ACK \n     -   [没有 accept，能建立 TCP 连接吗？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E6%B2%A1%E6%9C%89-accept-%E8%83%BD%E5%BB%BA%E7%AB%8B-tcp-%E8%BF%9E%E6%8E%A5%E5%90%97)\n          -  **可以的**，accpet 不参与 TCP 三次握手过程，用户层通过 accpet 系统调用拿到已经建立连接的 socket，对该 socket 进行读写\n     -   [没有 listen，能建立 TCP 连接吗？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E6%B2%A1%E6%9C%89-listen-%E8%83%BD%E5%BB%BA%E7%AB%8B-tcp-%E8%BF%9E%E6%8E%A5%E5%90%97)\n          -  **可以的**。客户端可以（**TCP自连接**），也可以两个客户端同时向对方发出请求建立连接（**TCP同时打开**），**没有服务端参与，也就是没有 listen，就能 TCP 建立连接","id":"e87d81f74c10158c","x":2500,"y":2900,"width":1380,"height":2240},
		{"id":"25a619a2c451024d","x":1790,"y":3047,"width":630,"height":393,"type":"text","text":" SYN 报文什么时候情况下会被丢弃？\n\n---\n\n-   [坑爹的 tcptwrecycle](https://xiaolincoding.com/network/3_tcp/syn_drop.html#%E5%9D%91%E7%88%B9%E7%9A%84-tcp-tw-recycle)\n    - 对于TIME WAIT 状态的优化中：\n\t    - **tcp_tw_recycle 在使用了 NAT 的网络下是不安全的！**\n\t    - 服务器同时开启了recycle 和 timestamps 选项，则会开启一种称之为「 per-host 的 PAWS 机制」（防止 TCP 包中的序列号seq绕回）\n\t         - 数据包中的时间戳值跟 Recent TSval 值比较，数据包中时间戳不是递增的，则过期丢弃\n\t    - per-host 的 PAWS 机制\n\t         - **对「对端 IP 做 PAWS 检查」**，而非对「IP + 端口」四元组做 PAWS 检查\n\t         - 客户端 A 通过 NAT 网关和服务器建立 TCP 连接，服务器主动关闭并且快速回收 TIME-WAIT 状态的连接后， B 也建立连接， A  B 经过相同的 NAT 网关，相同 IP ， B  timestamp 比  A  小，服务端 per-host 的 PAWS 机制，服务端就会丢弃B 发来的 SYN 包\n\t    - 如果它是对 TCP 四元组而不是对「相同的 IP 做 PAWS 检查」，没这个问题\n-   [accpet 队列满了](https://xiaolincoding.com/network/3_tcp/syn_drop.html#accpet-%E9%98%9F%E5%88%97%E6%BB%A1%E4%BA%86)\n    -   [半连接队列满了](https://xiaolincoding.com/network/3_tcp/syn_drop.html#%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E6%BB%A1%E4%BA%86)\n         -  开启syncookies  ![](lecture-note/Pasted%20image%2020230428153110.png)\n         - 应对 SYN 攻击时，设置为 1\n             - 防御 SYN 攻击：\n                 -   增大半连接队列；\n                     - 增大 tcp_max_syn_backlog 、somaxconn 和 backlog\n                 -   开启 tcp_syncookies 功能\n                 -   减少 SYN+ACK 重传次数\n    -   [全连接队列满了](https://xiaolincoding.com/network/3_tcp/syn_drop.html#%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E6%BB%A1%E4%BA%86)\n        -  TCP accpet 队列过小，或应用程序调用 accept() 不及时\n        -   ss 命令来看 accpet 队列大小\n             -  Recv-Q 的大小超过 Send-Q，发生了 accpet 队列满 \n        -   调大 accpet 队列的最大长度：调大 backlog 、 somaxconn \n-   检查系统或者代码为什么调用 accept() 不及时 "},
		{"id":"d55631f7993170a4","x":1800,"y":3560,"width":522,"height":480,"type":"text","text":"已建立连接的TCP，收到SYN会发生什么？\n\n---\n- 客户端的 SYN 报文里的端口号与历史连接不相同\n     - 建立新的连接\n     - 旧连接里处于 Established 状态的服务端\n         - 服务端发送了数据包,客户端连接已关，此时客户的内核就会回 RST ，服务端释放\n         - 没有发送数据包，TCP 保活机制检测到客户端没有存活后，服务端释放\n- 客户端的 SYN 报文里的端口号与历史连接相同\n    -  Established 状态的服务端，收到 SYN 报文（乱序的，初始化序列号是随机数），回复带正确序列号和确认号的 ACK 报文 Challenge ACK\n    - 客户端收到发现确认号（ack num）不是期望的，回 RST ，服务端收到释放\n-   [RFC 文档解释](https://xiaolincoding.com/network/3_tcp/challenge_ack.html#rfc-%E6%96%87%E6%A1%A3%E8%A7%A3%E9%87%8A)\n    \n-   [源码分析](https://xiaolincoding.com/network/3_tcp/challenge_ack.html#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90)\n    \n-   [如何关闭一个 TCP 连接？](https://xiaolincoding.com/network/3_tcp/challenge_ack.html#%E5%A6%82%E4%BD%95%E5%85%B3%E9%97%AD%E4%B8%80%E4%B8%AA-tcp-%E8%BF%9E%E6%8E%A5)\n    - 很难刚好伪造一个正确序列号的 RST 报文 \n    -   [killcx 的工具](https://xiaolincoding.com/network/3_tcp/challenge_ack.html#killcx-%E7%9A%84%E5%B7%A5%E5%85%B7)\n         -   Established 状态的服务端，收到四元组相同的 SYN 报文后， Challenge ACK，这里的「确认号」作为 RST 序列号，服务端释放连接\n         - 只能用来关闭活跃的 TCP 连接\n    -   [tcpkill 的工具](https://xiaolincoding.com/network/3_tcp/challenge_ack.html#tcpkill-%E7%9A%84%E5%B7%A5%E5%85%B7)\n         - 主动发送一个 SYN 报文，收到Challenge ACK，将序列号填充到伪造的 RST 报文，关闭 TCP 连接 \n         - 关闭活跃和非活跃连接\n-   [总结](https://xiaolincoding.com/network/3_tcp/challenge_ack.html#%E6%80%BB%E7%BB%93)"},
		{"id":"6123381cff1b15d8","x":1800,"y":4120,"width":522,"height":280,"type":"text","text":"四次挥手中收到乱序的 FIN 包会如何处理？\n\n---\n![](lecture-note/Pasted%20image%2020230428160744.png)\n - 在 FIN_WAIT_2 收到乱序的 FIN 报文，加入「乱序队列」，再次收到前面被网络延迟的数据包，判断乱序队列有没有数据,有可用的数据，找到与当前报文的序列号保持的顺序的报文，是否有 FIN 标志，有才进入 TIME_WAIT \n-   [TCP 源码分析](https://xiaolincoding.com/network/3_tcp/out_of_order_fin.html#tcp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90)\n    \n-   [怎么看 TCP 源码？](https://xiaolincoding.com/network/3_tcp/out_of_order_fin.html#%E6%80%8E%E4%B9%88%E7%9C%8B-tcp-%E6%BA%90%E7%A0%81)"},
		{"id":"8f9834421b66c109","x":1800,"y":4506,"width":580,"height":374,"type":"text","text":"在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？\n\n---\n\n-   [先说结论](https://xiaolincoding.com/network/3_tcp/time_wait_recv_syn.html#%E5%85%88%E8%AF%B4%E7%BB%93%E8%AE%BA)\n    - 客户端SYN 「序列号」「时间戳」比服务端「期望序列号」「最后收到的报文的时间戳」**大** \n    -   [收到合法 SYN](https://xiaolincoding.com/network/3_tcp/time_wait_recv_syn.html#%E6%94%B6%E5%88%B0%E5%90%88%E6%B3%95-syn)\n        -  重用此四元组连接，跳过 2MSL 而转变为 SYN_RECV 状态，接着建立连接过程\n        - ![](lecture-note/Pasted%20image%2020230428163411.png)\n    -   [收到非法的 SYN](https://xiaolincoding.com/network/3_tcp/time_wait_recv_syn.html#%E6%94%B6%E5%88%B0%E9%9D%9E%E6%B3%95%E7%9A%84-syn)\n        -  再回复一个第四次挥手的 ACK 报文，客户端收到后，不是期望确认号（ack num），回 RST\n        - ![](lecture-note/Pasted%20image%2020230428163518.png)\n-   [源码分析](https://xiaolincoding.com/network/3_tcp/time_wait_recv_syn.html#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90)\n    \n-   [在 TIME_WAIT 状态，收到 RST 会断开连接吗？](https://xiaolincoding.com/network/3_tcp/time_wait_recv_syn.html#%E5%9C%A8-time-wait-%E7%8A%B6%E6%80%81-%E6%94%B6%E5%88%B0-rst-%E4%BC%9A%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E5%90%97)\n     - 看 `net.ipv4.tcp_rfc1337` 这个内核参数（默认情况是为 0）：\n        -    0， 收到 RST 报文结束 TIME_WAIT 释放连接\n        -    1， 丢掉 RST 报文\n-   [总结](https://xiaolincoding.com/network/3_tcp/time_wait_recv_syn.html#%E6%80%BB%E7%BB%93)"},
		{"id":"ed1705df68748a72","x":1820,"y":5380,"width":560,"height":340,"type":"text","text":" 拔掉网线后， 原本的 TCP 连接还存在吗？\n\n---\n\n-   [拔掉网线后，有数据传输](https://xiaolincoding.com/network/3_tcp/tcp_unplug_the_network_cable.html#%E6%8B%94%E6%8E%89%E7%BD%91%E7%BA%BF%E5%90%8E-%E6%9C%89%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93)\n     -   在服务端重传次数没有达到最大值之前，客户端就插回了网线，原本的 TCP 连接正常存在，什么事情都没有发生\n      -   在客户端插回网线之前，服务端重传次数达到了最大值时，服务端断开 ,等到客户端插回网线发送数据，服务端回 RST ，客户端断开 TCP 连接\n-   [拔掉网线后，没有数据传输](https://xiaolincoding.com/network/3_tcp/tcp_unplug_the_network_cable.html#%E6%8B%94%E6%8E%89%E7%BD%91%E7%BA%BF%E5%90%8E-%E6%B2%A1%E6%9C%89%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93)\n      -   双方没有开启 TCP keepalive ，客户端不插回网线， TCP 连接状态将会一直保持\n      -   双方都开启了 TCP keepalive 机制，那探测到对方的 TCP 连接没有存活，断开 TCP 连接。探测期间，插回了网线，连接正常存在\n-   [总结](https://xiaolincoding.com/network/3_tcp/tcp_unplug_the_network_cable.html#%E6%80%BB%E7%BB%93)"},
		{"id":"40f3441f01ac6a25","x":1820,"y":4940,"width":459,"height":400,"type":"text","text":"TCP 连接，一端断电和进程崩溃有什么区别？\n\n---\n-   没有开启 keepalive\n    -  在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活 \n    -  通过 socket 接口设置 `SO_KEEPALIVE`\n-   一直没有数据交互\n-   [主机崩溃](https://xiaolincoding.com/network/3_tcp/tcp_down_and_crash.html#%E4%B8%BB%E6%9C%BA%E5%B4%A9%E6%BA%83)\n       - 没开启 TCP keepalive，没数据交互,客户端的「主机崩溃」,**服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态**，直到服务端重启进程\n-   [进程崩溃](https://xiaolincoding.com/network/3_tcp/tcp_down_and_crash.html#%E8%BF%9B%E7%A8%8B%E5%B4%A9%E6%BA%83)\n       - 服务端的进程崩溃后，内核回收该进程的所有 TCP 连接资源，发送第一次挥手 FIN 报文，完成挥手\n-   [有数据传输的场景](https://xiaolincoding.com/network/3_tcp/tcp_down_and_crash.html#%E6%9C%89%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%9A%84%E5%9C%BA%E6%99%AF)\n    -   [客户端主机宕机，又迅速重启](https://xiaolincoding.com/network/3_tcp/tcp_down_and_crash.html#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%BB%E6%9C%BA%E5%AE%95%E6%9C%BA-%E5%8F%88%E8%BF%85%E9%80%9F%E9%87%8D%E5%90%AF)\n        -  只要有一方重启完成后，收到之前 TCP 连接的报文，都会回复 RST 报文，以断开连接 \n    -   [客户端主机宕机，一直没有重启](https://xiaolincoding.com/network/3_tcp/tcp_down_and_crash.html#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%BB%E6%9C%BA%E5%AE%95%E6%9C%BA-%E4%B8%80%E7%9B%B4%E6%B2%A1%E6%9C%89%E9%87%8D%E5%90%AF)\n         -  服务端超时重传报文达到阈值 TCP 连接断开 \n-   [总结](https://xiaolincoding.com/network/3_tcp/tcp_down_and_crash.html#%E6%80%BB%E7%BB%93)"},
		{"id":"511cc6da67b50b2e","x":4083,"y":2900,"width":869,"height":993,"type":"text","text":"TCP 重传、滑动窗口、流量控制、拥塞控制\n\n---\n\n-   [重传机制](https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6)\n    -   [超时重传](https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0)---定时器\n         -   发生：\n             -   数据包丢失\n             -   确认应答丢失 \n        -  **超时重传时间 RTO 的值应该略大于报文往返 RTT 的值**，应该是一个**动态变化的值**\n             -  TCP 采样 RTT ，加权平均，算平滑 RTT ，且不断变化\n             -   采样 RTT 的波动范围，避免如果 RTT 有一个大的波动的话，很难被发现\n        -  每一次超时重传，下一次设为先前值的两倍。两次超时网络环境差，不宜频繁发送\n    -   [快速重传](https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0)\n        - **不以时间为驱动，而是以数据驱动重传**\n        - but **重传的时候，是重传一个，还是重传所有**？\n    -   [SACK 方法](https://xiaolincoding.com/network/3_tcp/tcp_feature.html#sack-%E6%96%B9%E6%B3%95)\n        -  TCP 头部「选项」字段里加一个 `SACK` 将已收到的数据的信息发送给「发送方」只重传丢失的数据 \n    -   [Duplicate SACK](https://xiaolincoding.com/network/3_tcp/tcp_feature.html#duplicate-sack)\n        -  用 SACK 告诉「发送方」哪些数据被重复接收了 \n-   [滑动窗口](https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3)\n     - 窗口大小:无需等待确认应答，而可以继续发送数据的最大值\n     - **累计确认**或者**累计应答**\n     - 接收方的窗口大小决定\n     - 发送方： ![](lecture-note/Pasted%20image%2020230427182424.png)\n     - 接收方：![](lecture-note/Pasted%20image%2020230427182836.png)\n     - 接收窗口**约等于**发送窗口的大小的\n         - 滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话接收窗口可以很快空缺出来。新的接收窗口大小通过 TCP 报文中的 Windows 字段来告诉发送方。传输过程存在时延的，\n-   [流量控制](https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6)\n     TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量![](lecture-note/Pasted%20image%2020230427183450.png)\n    -   [操作系统缓冲区与滑动窗口的关系](https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB)\n        -  操作系统的缓冲区如何影响发送、接收窗口 ？\n             -  服务端非常的繁忙，当收到客户端的数据时，应用层不能及时读取数据![](lecture-note/Pasted%20image%2020230427184537.png)\n             - 服务端系统资源紧张，操作系统减少接收缓冲区大小，应用程序无法及时读取缓存数据，数据包丢失  ![](lecture-note/Pasted%20image%2020230427193841.png)\n             - **防止丢包**：TCP 规定是不允许同时减少缓存又收缩窗口的，而是先收缩窗口，过段时间再减少缓存\n    -   [窗口关闭](https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E7%AA%97%E5%8F%A3%E5%85%B3%E9%97%AD)\n         -  ![](lecture-note/Pasted%20image%2020230427194438.png)\n         - TCP 解决窗口关闭潜在的死锁现象呢？\n              -  **TCP 连接一方收到零窗口通知，启动持续计时器**，超时发**窗口探测 ( Window probe ) 报文** 给出自己现在的接收窗口大小  ![](lecture-note/Pasted%20image%2020230427195531.png)\n    -   [糊涂窗口综合症](https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E7%B3%8A%E6%B6%82%E7%AA%97%E5%8F%A3%E7%BB%BC%E5%90%88%E7%97%87)\n         -  接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节\n         -  发生在发送方和接收方：\n             -   接收方可以通告一个小的窗口\n             -   而发送方可以发送小数据\n        - 解决：都别\n             -  窗口大小 >= MSS  \n             -   Nagle 算法：延时处理，满足任意一个，才可以发送数据：\n                  -   窗口大小 >= `MSS` 并且 数据大小 >= `MSS`；\n                  -   收到之前发送数据的 `ack` 回包\n            接收方满足「不通告小窗口给发送方」+ 发送方开启 Nagle 算法\n-   [拥塞控制](https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6)**避免「发送方」的数据填满整个网络**\n    -  **拥塞窗口 cwnd**是发送方维护的状态变量，根据**网络的拥塞程度动态变化的*\n    -  发生了超时重传，就会认为网络出现了拥塞。\n    -   [慢启动](https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E6%85%A2%E5%90%AF%E5%8A%A8)\n         -  **当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1**\n         -  ![](lecture-note/Pasted%20image%2020230427200557.png)\n         - 慢启动门限 `ssthresh` （slow start threshold）（`65535` 字节）\n             -   `cwnd` < `ssthresh` 时，慢启动算法。\n             -   `cwnd` >= `ssthresh` 时「拥塞避免算法」\n    -   [拥塞避免算法](https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%AE%97%E6%B3%95)\n         -  **每当收到一个 ACK 时，cwnd 增加 1/cwnd** \n    -   [拥塞发生](https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F)\n         -  丢包触发重传，进入了「拥塞发生算法」 \n         - 超时重传：\n             -   `ssthresh` 设为 `cwnd/2`，\n             -   `cwnd` 重置为 `1` \n             ![](lecture-note/Pasted%20image%2020230427201442.png)\n        - 快速重传：\n            -   `cwnd = cwnd/2` ，也就是设置为原来的一半;\n            -   `ssthresh = cwnd`;\n            -   进入快速恢复算法\n    -   [快速恢复](https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D)\n         -  ![](lecture-note/Pasted%20image%2020230427201744.png)\n         -  为什么收到新的数据后，cwnd 设置回了 ssthresh？\n              -  快速恢复目的仍然是降低 cwnd 来减缓拥塞\n              - （cwnd逐渐加1）为了尽快将丢失的数据包发给目标，解决拥塞的根本问题（三次相同的 ACK 导致的快速重传）\n-   [读者问答](https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E8%AF%BB%E8%80%85%E9%97%AE%E7%AD%94)"},
		{"id":"209ec98f07cb2540","x":4083,"y":3971,"width":632,"height":722,"type":"text","text":"TCP 实战抓包分析\n\n---\n\n-   [显形“不可见”的网络包](https://xiaolincoding.com/network/3_tcp/tcp_tcpdump.html#%E6%98%BE%E5%BD%A2-%E4%B8%8D%E5%8F%AF%E8%A7%81-%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8C%85)\n     先用 tcpdump 命令在 Linux 服务器上抓包，接着把抓包的文件拖出到 Windows 电脑后，用 Wireshark 可视化分析\n-   [解密 TCP 三次握手和四次挥手](https://xiaolincoding.com/network/3_tcp/tcp_tcpdump.html#%E8%A7%A3%E5%AF%86-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B)\n      ![](lecture-note/Pasted%20image%2020230427203023.png)\n      -  为什么抓到的 TCP 挥手是三次，而不是书上说的四次\n          -  被动关闭方（上图的服务端）「**没有数据要发送」并且「开启了 TCP 延迟确认机制」，第二三次挥手合并传输\n-   [TCP 三次握手异常情况实战分析](https://xiaolincoding.com/network/3_tcp/tcp_tcpdump.html#tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90)\n    -   [实验场景](https://xiaolincoding.com/network/3_tcp/tcp_tcpdump.html#%E5%AE%9E%E9%AA%8C%E5%9C%BA%E6%99%AF)\n    -   [实验一：TCP 第一次握手 SYN 丢包](https://xiaolincoding.com/network/3_tcp/tcp_tcpdump.html#%E5%AE%9E%E9%AA%8C%E4%B8%80-tcp-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B-syn-%E4%B8%A2%E5%8C%85)\n         -  客户端发起了 SYN 包后，没有收到 ACK ，超时重传 5 次 \n         -  每次超时时间 RTO 是**指数（翻倍）上涨的**\n         -  `tcp_syn_retries` 默认值为 5\n    -   [实验二：TCP 第二次握手 SYN、ACK 丢包](https://xiaolincoding.com/network/3_tcp/tcp_tcpdump.html#%E5%AE%9E%E9%AA%8C%E4%BA%8C-tcp-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B-syn%E3%80%81ack-%E4%B8%A2%E5%8C%85)\n         -  客户端会超时重发 SYN 包，\n         - 服务端也会超时重传 SYN、ACK 包,**但是SYN、ACK包的重传定时器并没有重置，会继续重传，直到达到重传到最大次数**tcp_synack_retries\n    -   [实验三：TCP 第三次握手 ACK 丢包](https://xiaolincoding.com/network/3_tcp/tcp_tcpdump.html#%E5%AE%9E%E9%AA%8C%E4%B8%89-tcp-%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-ack-%E4%B8%A2%E5%8C%85)\n         -  服务端处于 `SYN_RECV` 状态，客户端`ESTABLISHED` \n         - 服务端重传 SYN、ACK 包，超过 `tcp_synack_retries` 值（默认值 5 次）后断开 TCP 连接。\n         - 而客户端则会有两种情况：\n             -   客户端没发送数据包， `ESTABLISHED` 状态， 2 小时 11 分 15 秒发现「死亡」连接，断开\n              -   发了数据包，没收到确认报文，重传， `tcp_retries2` 值（默认值 15 次）后，客户端断开  \n-   [TCP 快速建立连接](https://xiaolincoding.com/network/3_tcp/tcp_tcpdump.html#tcp-%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5)\n     - ![](lecture-note/Pasted%20image%2020230427204639.png)\n     -  ![](lecture-note/Pasted%20image%2020230427204652.png)\n     -  `net.ipv4.tcp_fastopen` 内核参数，来打开 Fast Open\n-   [TCP 重复确认和快速重传](https://xiaolincoding.com/network/3_tcp/tcp_tcpdump.html#tcp-%E9%87%8D%E5%A4%8D%E7%A1%AE%E8%AE%A4%E5%92%8C%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0)\n      - **发送方收到 3 个重复 ACK 时，就会触发快速重传，立刻重发丢失数据包**\n      -  TCP 三次握手时协商开启 SACK**，只需要重传丢失的数据包\n          - 如果要支持 `SACK`，必须双方都要支持。在 Linux 下，`net.ipv4.tcp_sack` （Linux 2.4 后默认打开）\n-   [TCP 流量控制](https://xiaolincoding.com/network/3_tcp/tcp_tcpdump.html#tcp-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6)\n    -   [零窗口通知与窗口探测](https://xiaolincoding.com/network/3_tcp/tcp_tcpdump.html#%E9%9B%B6%E7%AA%97%E5%8F%A3%E9%80%9A%E7%9F%A5%E4%B8%8E%E7%AA%97%E5%8F%A3%E6%8E%A2%E6%B5%8B)\n         -  发送方会**定时发送窗口大小探测报文** TCP Keep-Alive，以便及时知道接收方窗口大小的变化  超时时间会**翻倍**\n    -   [发送窗口的分析](https://xiaolincoding.com/network/3_tcp/tcp_tcpdump.html#%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3%E7%9A%84%E5%88%86%E6%9E%90)\n         -  Windows size 也就是 \" win = \" 向对方声明自己的接收窗口 \n         - 「Window size value」 * 「Window size scaling factor」 = 「Caculated window size 」\n         -  发送窗口的大小  min(拥塞窗口，接收窗口)\n         -  发送窗口决定了一次发多少字节， MSS 决定分多少包发完\n         -  累计确认：收到多个数据包时，只应答最后一个的 ACK \n-   [TCP 延迟确认与 Nagle 算法](https://xiaolincoding.com/network/3_tcp/tcp_tcpdump.html#tcp-%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4%E4%B8%8E-nagle-%E7%AE%97%E6%B3%95)\n     -  Nagle 算法\n        -  窗口大小 >= `MSS` 并且 数据大小 >= `MSS`\n        -   收到之前发送数据的 `ack`\n    - TCP 延迟确认（HZ）的策略：\n         -   有响应数据，和ACK一起发 \n         -   没有则等待是否有响应数据一起发送\n         -   在延迟等待发送 ACK 期间，第二个数据报文到达了，立刻发 ACK\n    -  混合使用时，会导致时耗增长\n         -  ![](lecture-note/Pasted%20image%2020230427212737.png)\n         - 解决：双方得关一个\n-   [读者问答](https://xiaolincoding.com/network/3_tcp/tcp_tcpdump.html#%E8%AF%BB%E8%80%85%E9%97%AE%E7%AD%94)\n    \n-   [最后](https://xiaolincoding.com/network/3_tcp/tcp_tcpdump.html#%E6%9C%80%E5%90%8E)"},
		{"id":"8d864ec57ab88104","x":4109,"y":4880,"width":580,"height":460,"type":"text","text":"-   [TCP 三次握手的性能提升](https://xiaolincoding.com/network/3_tcp/tcp_optimize.html#tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87)\n    -  `netstat` 命令查看是哪个握手阶段出现了问题  \n    -   [客户端优化](https://xiaolincoding.com/network/3_tcp/tcp_optimize.html#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%98%E5%8C%96)\n         -  SYN 的全称就叫 _Synchronize Sequence Numbers_（同步序列号）\n         -  SYN_SENT 状态的优化:**tcp_syn_retries**\n    -   [服务端优化](https://xiaolincoding.com/network/3_tcp/tcp_optimize.html#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BC%98%E5%8C%96)\n         -  ![](lecture-note/Pasted%20image%2020230427213720.png)\n         -  查看由于 SYN 半连接队列已满被丢弃连接的情况：netstat -s\n         -  调整 SYN 半连接队列：\n             -   tcp_max_syn_backlog + somaxconn + backlog   \n             -  开启 syncookies ，在不使用 SYN 半连接队列的情况下成功建立连接\n        -  SYN_RCV 状态的优化\n             - 服务器没有收到 ACK，就会重发 SYN+ACK 报文，同时一直处于 SYN_RCV\n             -  网络繁忙不稳定，报文丢失，调大重发次数。反之调小。 tcp_synack_retries\n        -  收到 ACK 后连接建立，内核会把连接从半连接队列移除，创建新的完全的连接添加到 accept ，等待进程调用 accept 把连接取出来\n             -  ![](lecture-note/Pasted%20image%2020230427220336.png)\n             -   tcp_abort_on_overflow 设置为 0更有利于应对突发流量\n         - 调整 accept 队列的长度:min(somaxconn, backlog)\n         -  查看服务端进程 accept 队列的长度: ss -ltn\n         -  查看由于 accept 连接队列已满，而被丢弃的连接: netstat -s\n    -   [如何绕过三次握手？](https://xiaolincoding.com/network/3_tcp/tcp_optimize.html#%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B)\n         - TCP Fast Open\n             -  开启了 TFO 功能，cookie 存在TCP option 字段\n                  - ![](lecture-note/Pasted%20image%2020230427220903.png)\n             -  打开 TCP Fast Open： **tcp_fastopn**\n    -   [小结](https://xiaolincoding.com/network/3_tcp/tcp_optimize.html#%E5%B0%8F%E7%BB%93)\n         -  ![](lecture-note/Pasted%20image%2020230427221024.png)\n         - \n-   [TCP 四次挥手的性能提升](https://xiaolincoding.com/network/3_tcp/tcp_optimize.html#tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87)\n    -   [主动方的优化](https://xiaolincoding.com/network/3_tcp/tcp_optimize.html#%E4%B8%BB%E5%8A%A8%E6%96%B9%E7%9A%84%E4%BC%98%E5%8C%96)\n        -  没收到对方的 ACK 回复，重传 FIN 报文`tcp_orphan_retries` 参数决定。\n        - 收到 ACK 报文后， FIN_WAIT2 状态，关闭的方式不同，优化的方式也不同：\n            -  close 函数，它就是孤儿连接。 `tcp_fin_timeout` 秒内没有收到 FIN ，直接关闭。应对孤儿连接占用太多的资源，`tcp_max_orphans` 超过时连接就会直接释放。\n            -   反之是 shutdown 函数关闭的连接，则不受此参数限制；\n        - 收到 FIN 报文返回 ACK 后，主动方 TIME_WAIT 状态持续 1 分钟，防止 TIME_WAIT 状态占用太多的资源，`tcp_max_tw_buckets` 超过时连接也会直接释放。\n             -   TIME_WAIT 状态过多时，`tcp_tw_reuse` 和 `tcp_timestamps` 为 1 ，将 TIME_WAIT 状态的端口复用于作为客户端的新连接，只适用于客户端 \n    -   [被动方的优化](https://xiaolincoding.com/network/3_tcp/tcp_optimize.html#%E8%A2%AB%E5%8A%A8%E6%96%B9%E7%9A%84%E4%BC%98%E5%8C%96)\n         -  出现大量 CLOSE_WAIT 状态的连接时，从应用程序中找问题。\n         - 被动方发送 FIN 报文后， LAST_ACK 状态未等到 ACK 时， `tcp_orphan_retries` 重发 FIN 报文 \n    -   [小结](https://xiaolincoding.com/network/3_tcp/tcp_optimize.html#%E5%B0%8F%E7%BB%93-2)\n         -  ![](lecture-note/Pasted%20image%2020230427221103.png) \n-   [TCP 传输数据的性能提升](https://xiaolincoding.com/network/3_tcp/tcp_optimize.html#tcp-%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E7%9A%84%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87)\n    -  TCP 连接是由内核维护的，内核会为每个连接建立内存缓冲区 \n    -   [滑动窗口是如何影响传输速度的？](https://xiaolincoding.com/network/3_tcp/tcp_optimize.html#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%98%AF%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E4%BC%A0%E8%BE%93%E9%80%9F%E5%BA%A6%E7%9A%84)\n        -  **TCP 报文发出去后，并不会立马从内存中删除，重传时还需要用到它。 TCP 是内核维护的，所以报文存放在内核缓冲区 \n        -  **并行批量发送报文，再批量确认报文即可**\n             -  得考虑接收方的处理能力---滑动窗口\n                 -   TCP 报文头部中的**窗口字段** \n                     - ![](lecture-note/Pasted%20image%2020230427222338.png)\n                     -  选项字段定义了窗口扩大因子，2^14，窗口大小从 16 位扩大为 30 位（2^16 * 2^ 14 = 2^30），最大值可以达到 1GB。\n                        -  ![](lecture-note/Pasted%20image%2020230427222458.png)\n                        \n    -   [如何确定最大传输速度？](https://xiaolincoding.com/network/3_tcp/tcp_optimize.html#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E9%80%9F%E5%BA%A6)\n         -  ![](lecture-note/Pasted%20image%2020230428132845.png)\n         - 网络一共可以存放 100MB/s * 0.01s = 1MB 的字节\n         - 发送缓冲区决定了发送窗口上限---决定「已发送未确认」的飞行报文的上限。因此，发送缓冲区不能超过「带宽时延积」\n    -   [怎样调整缓冲区大小？](https://xiaolincoding.com/network/3_tcp/tcp_optimize.html#%E6%80%8E%E6%A0%B7%E8%B0%83%E6%95%B4%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F)\n         - 调节发送缓冲区tcp_wmem，自行调节\n         -  调节接收缓冲区tcp_rmem 根据系统空闲内存的大小来调节接收窗口，**tcp_moderate_rcvbuf 为 1 来开启**\n         - 调节 TCP 内存 tcp_mem\n         - 根据实际场景调节的策略：\n             -  保证缓冲区的动态调整的最大值达到带宽时延积，最小值默认的 4K 不变。内存紧张调低默认值\n             - 网络 IO 型服务器，调大 tcp_mem \n             - tcp_wmem 和 tcp_rmem 的单位是字节，而 tcp_mem 的单位是页面大小\n             - 不要在 socket 上直接设置 SO_SNDBUF 或者 SO_RCVBUF，会关闭缓冲区的动态调整功能\n    -   [小结](https://xiaolincoding.com/network/3_tcp/tcp_optimize.html#%E5%B0%8F%E7%BB%93-3)"},
		{"id":"379884a9b1ae8b6c","x":4397,"y":5440,"width":555,"height":280,"type":"text","text":"## TCP Fast Open + TLSv1.3\n\n客户端和服务端同时支持 TCP Fast Open 功能的情况下，**在第二次以后到通信过程中，客户端可以绕过三次握手直接发送数据，而且服务端也不需要等收到第三次握手后才发送数据。**\n\nTLS 版本是 1.3， 1-RTT。\n「TCP Fast Open + TLSv1.3」:TLS 和 TCP 的握手可以同时进行\n\n基于 TCP Fast Open 场景下的 TLSv1.3 0-RTT 会话恢复过程，握手过程和 HTTP 请求也可以一同完成"},
		{"id":"d02c8a57863df18f","x":3823,"y":5440,"width":520,"height":380,"type":"text","text":"如何理解是 TCP 面向字节流协议？\n\n---\n\n-   [如何理解字节流？](https://xiaolincoding.com/network/3_tcp/tcp_stream.html#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%AD%97%E8%8A%82%E6%B5%81)\n    -  为什么 UDP 是面向报文的协议\n        - UDP ,操作系统不会对消息拆分 \n        - 每个 UDP 报文就是一个用户消息的边界\n        - 队列里的每一个元素就是一个 UDP 报文\n    -   TCP 是面向字节流的协议？\n        - 会被操作系统分成多个 TCP 报文\n        - send “发送”，数据从应用程序拷贝到了操作系统内核协议栈中,真正发送取决于发送、拥塞窗口、当前发送缓冲区的大小等\n        - so不能认为一个用户消息对应一个 TCP 报文，所以 TCP 是面向字节流的协议\n-   [如何解决粘包？](https://xiaolincoding.com/network/3_tcp/tcp_stream.html#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%B2%98%E5%8C%85)\n    -   [特殊字符作为边界](https://xiaolincoding.com/network/3_tcp/tcp_stream.html#%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E4%BD%9C%E4%B8%BA%E8%BE%B9%E7%95%8C):HTTP\n    -   [自定义消息结构](https://xiaolincoding.com/network/3_tcp/tcp_stream.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF%E7%BB%93%E6%9E%84)"},
		{"type":"text","text":"- HTTP :  \n    - url :         ![](lecture-note/Pasted%20image%2020230422160822.png)\n- ip:    DNS----缓存----根/顶级/权威 \n- 协议栈：     ![](lecture-note/Pasted%20image%2020230422160625.png)\n    - TCP:      ![](lecture-note/Pasted%20image%2020230422161324.png)\n         - 三次握手：      ![](lecture-note/Pasted%20image%2020230422161528.png)\n             -   TCP 的连接状态查看：在 Linux 可以通过 `netstat -napt` 命令\n                  ![](lecture-note/Pasted%20image%2020230422161733.png)\n             -  TCP 分割数据      \n                 ![](lecture-note/Pasted%20image%2020230422162028.png)\n                 ![](lecture-note/Pasted%20image%2020230422162350.png)\n            - TCP 报文生成\n                 ![](lecture-note/Pasted%20image%2020230422162702.png)\n     - IP：\n         - TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成**网络包**发送给通信对象\n         ![](lecture-note/Pasted%20image%2020230422164256.png)\n        -  IP 包头的**协议号**: `06`（十六进制），表示协议为 TCP\n             - 客户端有多个网卡---多个 IP 地址，**源地址**选择哪个 IP ？\n                 -  **路由表**规则:    Linux 操作系统，我们可以使用 `route -n`\n                     ![](lecture-note/Pasted%20image%2020230422163537.png)\n                    -  假设 Web 服务器的目标地址是 `192.168.10.200`\n                     ![](lecture-note/Pasted%20image%2020230422163623.png)\n     - MAC 包头格式:\n         - ![](lecture-note/Pasted%20image%2020230422164445.png)\n         - 用于**两点之间的传输**\n         - 一般在 TCP/IP 通信里，MAC 包头的**协议类型**只使用：\n             -  `0800` ： IP 协议\n             -  `0806` ： ARP 协议\n             -  **发送方**:网卡的ROM里\n             -  接收方：**路由表**，找到匹配条目，把包发给 `Gateway` 列中的 IP 地址\n                  - 如何获取对方的 MAC 地址？\n                     -   ARP 协议：先查ARP 缓存（arp -a） ，没有就在以太网中**广播**\n    - 至此，网络包的报文： \n         - ![](lecture-note/Pasted%20image%2020230422165507.png)\n     - 网卡：  **数字信息转换为电信号**，发到网线【包的接收方 MAC 地址是不是发给自己的，不是则丢弃】\n         ![](lecture-note/Pasted%20image%2020230422165747.png)\n     - 交换机：电信号转换为数字信号，`FCS` 校验错误，放到缓冲区\n            ![](lecture-note/Pasted%20image%2020230422171918.png)\n         -  MAC 地址表找不到指定的 MAC 地址会怎么样？\n            -  交换机无法判断把包转发到哪个端口，就转发到除了源端口之外的所有端口，**只有相应的接收者才接收包，而其他设备则会忽略这个包**\n     - 路由器：   \n         - **路由器**是基于 IP 设计的，俗称**三层**网络设备\n         - 电信号转换为数字信号，`FCS` 校验错误,MAC地址查看是不是给自己的，**去掉** MAC 头部【**作用就是将包送达路由器**】，根据IP头部包转发【查路由表：IP+子网掩码与运算匹配目标地址】，根据**路由表的网关列**判断：\n            - 是 IP 地址：继续转发\n                -  接收方MAC：\n                    -   `ARP` 协议：\n                        - 先在路由器的 ARP 缓存查\n                        - 没有：根据 IP 地址查询 MAC 地址，结果作为接收方 MAC 地址。\n                - 发送方 MAC ：输出端口的 MAC 地址。还有一个以太类型字段，填写 `0800` （十六进制）表示 IP 协议。\n     - 网络包传输的过程中，**源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址**，因为需要 MAC 地址在以太网内进行**两个设备**之间的包传输\n    - 服务器与客服端：    \n         ![](lecture-note/Pasted%20image%2020230422174714.png)\n        - 服务器--MAC(地址)---IP（TCP协议）---TCP（序列号---缓存，端口号---HTTP服务器）---HTTP进程（响应报文）---穿TCP/IP/MAC---网卡---交换机---路由器（IP）---交换机---客户端（扒，离开---TCP四次挥手）","id":"536df835168ca0c1","x":987,"y":2760,"width":720,"height":720}
	],
	"edges":[]
}